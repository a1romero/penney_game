# Penney’s Game Simulation

This project simulates a version of Penney’s Game played with cards in order to determine the optimal starting sequences. A full explanation of the game can be found [here](https://en.wikipedia.org/wiki/Penney%27s_game). 

Variation 1: The player whose sequence appeared receives all of the cards in the pile, the pile is cleared, and the game continues until the deck is exhausted. Any remaining cards at the end of the game are discarded. The player with the most cards in their pile wins.
Variation 2: The player whose sequence appeared receives a point for winning the “trick”. The card pile is cleared, and the game continues until the deck is exhausted. Any remaining cards at the end of the game are discarded. The player who won the most tricks wins the game.

Files included:

**data/** Stores win results for Player 2 for each play (iteration). Each file is titled by a number representing the play pattern converted into a number using base 2.
- data_variation_1: Stores win results for Player 2 for game plays on variation 1.
- data_variation_2: Stores win results for Player 2 for game plays on variation 2.

**src/**
- penney_game.py: contains all of the functions necessary to run the simulation. The run_simulation() function generates a specified number of games under a specified variation and returns the finished heatmap.

**penney_game**
- penney_game_simulation.ipynb: a file which runs the code from penney_game.py
- .gitignore: specifies which files or directories should be ignored by git 


## How it works

The run_simulation() function plays a specified number of games and automatically runs two variations: winning by number of cards (variation 1) and winning by number of tricks (variation 2). The function also allows the user to set a random seed for reproducibility.

The decks are generated by shuffling an array of 26 zeros (representing black cards) and 26 ones (representing red cards). The winner of each game is determined by iterating through the deck and checking which player's specified sequence appears more frequently, either by the number of cards collected (variation 1) or by the number of tricks won (variation 2).

Results are saved in numpy arrays, with Player 2 wins recorded as zeros and Player 1 wins recorded as ones. These results are stored in the corresponding folder (based on the variation) within the data directory.

Once all games for each Player 1 / Player 2 sequence combination are played, a heatmap is generated. The heatmap shows the percentage of games won by Player 2 for each sequence pairing, with the color scale ranging from dark green (high win ratio for Player 2) to dark red (low win ratio for Player 2). The full win ratio can be viewed by hovering over each box in the interactive plot.

## Work Distribution Write Up:
**Simulation Team**:

Evan: Helped with initial deck creation and simulation. Created a wrapper function that plays a specified number of games by calling our deck generation function and our function that determines the winner based on the inputted deck. 

Cynthia: Wrote simulation function: randomly generates user-specified number of card decks, represented by a string.

**Data Management Team**:

Paola: Wrote and debugged determine_winner() function. Focused on iterating through the play pattern given by the simulation team and determining who won the round for specific variation. 

Al: Added code to determine_winner() to return and save an array as a .npy file. Wrote code to iterate over the stored arrays and find the win percentage. Coded a combined function to export a win percentage array.

Mary: Tested determine_winner()  function. Wrote function to run all combinations. Helped combine all functions in one .py file so heatmap can be generated with one line of code. Checked final probabilities and corrected labeling issues with heatmap.  

**Visualization Team**:

Arianna: Wrote the create_heatmap() function and tested it on sample data.
